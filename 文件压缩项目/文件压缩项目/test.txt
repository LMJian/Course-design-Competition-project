#pragma once
#include<iostream>
#include<fstream>
#include<queue>
#include<string>
using namespace std;

struct HuffManTreeNode {
	HuffManTreeNode(int weight, unsigned char ch = 0)
		:pLeft_(nullptr)
		,pRight_(nullptr)
		,Weight_(weight)
		,Ch_(ch)
	{}
	HuffManTreeNode *pLeft_;
	HuffManTreeNode *pRight_;
	int Weight_;                       //权值
	unsigned char Ch_;                 //待压缩字符
};

class Less {                  //要小堆
public:
	bool operator()(const HuffManTreeNode* pLeft, const HuffManTreeNode* pRight) {
		return pLeft->Weight_ > pRight->Weight_;
	}
};

class FileCompressionHuffManTree {
	typedef HuffManTreeNode Node;
	typedef HuffManTreeNode* PNode;
public:
	FileCompressionHuffManTree(const string fileName = "test.txt")
		:fileName_(fileName)
		, root_(nullptr)
	{}
	~FileCompressionHuffManTree() {
		//释放二叉树节点空间
		//未完成
	}
	void InitQue() {
		FILE *pFile = fopen(fileName_.c_str(), "r");
		if (pFile == NULL) {
			perror("fopen file error!");
			return;
		}
		unsigned char buf[1024] = { 0 };   //一次读取文件的1024个字节
										   //这里不能出现负数，因为无法作为count数组的下标，所以要用unsigned char 
		while (1) {
			int n = fread(buf, 1, 1024, pFile);
			for (int i = 0; i < n; ++i) {
				++count[buf[i]];
			}
			if (n < 1024)
				break;
		}
		for (int i = 0; i < 256; ++i) {
			if (count[i] > 0) {
				PNode ptr = new Node(count[i], i);
				que_.push(ptr);
			}
		}
		fclose(pFile);
	}
	void InitTree() {                     //将队列里的结点初始化为二叉树
		while (que_.size() > 1) {
			PNode left = que_.top();
			que_.pop();
			PNode right = que_.top();
			que_.pop();
			PNode newNode = new Node(left->Weight_ + right->Weight_);
			newNode->pLeft_ = left;
			newNode->pRight_ = right;
			que_.push(newNode);
		}
		root_ = que_.top();
		que_.pop();
	}
	void WriteBin() {     //开始压缩
		if (root_)
			InitChPW(root_, "");    //获取每个字符对应的密码

		FILE *pRead = fopen(fileName_.c_str(), "r");
		FILE *pWrite = fopen("test.bin", "w");
		if (pRead == NULL || pWrite == NULL) {
			perror("fopen file error!");
			return;
		}
		//写入头部信息
		string headstr = "";
		int rows = 0;
		for (int i = 0; i < 256; ++i) {
			if (count[i] > 0) {
				char ch = i;
				int ret = count[i];
				char str[1024] = { 0 };
				sprintf(str, "%d:%d\n", ch, ret);
				headstr += str;
				++rows;
			}
		}
		char str[1024] = { 0 };
		sprintf(str, "%d\n", rows);
		headstr = str + headstr;
		fwrite(headstr.c_str(), 1, headstr.size(), pWrite);
		unsigned char buf[1024] = { 0 };     //一次压缩1024个字节的文件内容
		char ch = 0;
		int index = 0;
		while (1) {
			size_t n = fread(buf, 1, 1024, pRead);
			for (size_t i = 0; i < n; ++i) {
				string passWord = charPassWord[buf[i]];        //读取buf[i]对应的密码
				for (size_t j = 0; j < passWord.size(); ++j) {
					ch <<= 1;
					++index;
					if (passWord[j] == '1') {
						ch = ch ^ 1;
					}
					else {
						ch = ch ^ 0;
					}
					if (index == 8) {
						fwrite(&ch, 1, 1, pWrite);
						index = 0;
						ch = 0;
					}
				}
			}
			if (n < 1024)
				break;
		}
		if(index > 0){
			ch = ch << (8 - index);
			fwrite(&ch, 1, 1, pWrite);
		}
		fclose(pRead);
		fclose(pWrite);
	}

private:
	void InitChPW(PNode ptr,string pw) {
		if (!ptr->pLeft_ && !ptr->pRight_) {    //当它为叶子节点时
			charPassWord[ptr->Ch_] = pw;
			return;
		}
		if (ptr->pLeft_)
			InitChPW(ptr->pLeft_, pw + "0");
		if (ptr->pRight_)
			InitChPW(ptr->pRight_, pw + "1");
	}
	PNode root_;                                       //树的根节点
	string fileName_;                                  //要压缩的文件名
	priority_queue<PNode,vector<PNode>,Less> que_;     //优先队列，小根堆
	string charPassWord[256];                          //字符对应的密码
	int count[256] = { 0 };                            //统计字符出现的次数
};
